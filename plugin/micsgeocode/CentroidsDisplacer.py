## ###########################################################################
##
# CentroidsDisplacer.py
##
# Author: Etienne Delclaux
# Created: 17/03/2021 11:15:56 2016 (+0200)
##
# Updated: Nazim Gashi
# Time: 06/05/2024 13:00:00 (Edits/adds done between 405-429)
# Time: 08/01/2025 15:00:00 (lines (307 and 310) & (372 and 375) added) (updates done between 231-253; also 306, 308, and 309)
##
# Description:
##
## ###########################################################################


# ToDo: for buffers crossing antimeridian, use a modified CS: "GEOGCRS["WGS 84",
#     DATUM["World Geodetic System 1984",
#         ELLIPSOID["WGS 84",6378137,298.257223563,
#             LENGTHUNIT["metre",1]]],
#     PRIMEM["Greenwich",180,
#         ANGLEUNIT["degree",0.0174532925199433]],
#     CS[ellipsoidal,2],
#         AXIS["geodetic latitude (Lat)",north,
#             ORDER[1],
#             ANGLEUNIT["degree",0.0174532925199433]],
#         AXIS["geodetic longitude (Lon)",east,
#             ORDER[2],
#             ANGLEUNIT["degree",0.0174532925199433]],
#     USAGE[
#         SCOPE["unknown"],
#         AREA["World"],
#         BBOX[-90,-180,90,180]]]"

import math
import random
import typing
from datetime import datetime

from qgis.core import *  # QGIS3
from qgis.PyQt.QtCore import QVariant

from . import CentroidBuffersMaxDistanceComputer as Radier
from . import CentroidsLoader as CentroidsLoader
from . import Errors
from . import ReferenceLayer as ReferenceLayer
from . import Utils
from .Logger import Logger
from .Transforms import Transforms, CRS

## #############################################################
# Centroids Displacer
## #############################################################


class CentroidsDisplacer():
    """ Handle the centroids displacement.
        The existing centroids are available through a map layer.
    """

    MAX_ITERATIONS = 20

    def __init__(self):
        self.__generatedLayers = {}  # layer collection for centroids dispalcement
        self.ref_id_field = ""
        self.referenceLayer = ReferenceLayer.ReferenceLayer()
        self.centroidLayer = None
        self.cluster_no_field = ""
        self.cluster_type_field = ""

        self.maxDistances = None

    def displaceCentroids(self) -> typing.NoReturn:
        """ Facade method that handle all the centroids displacement.
        """
        Logger.logInfo("[CentroidsDisplacer] Centroids displacement starts at {}".format(datetime.now()))

        self.clearLayers()

        radier = Radier.CentroidBuffersMaxDistanceComputer()
        radier.centroidLayer = self.centroidLayer
        radier.computeBufferRadiusesCentroids()
        self.maxDistances = radier.maxDistance

        self.__createOutputsMemoryLayer()

        # Displace points
        #crs_transformation = None
        for cluster_centroid_ft in self.centroidLayer.getFeatures():
            #if not crs_transformation:
            # obtain the target transformation
            pt = QgsGeometry(cluster_centroid_ft.geometry()).asPoint() 
            crs_transformation = Transforms(pt.y(), pt.x())
            print(f"[CentroidsDisplacer] Using EPSG {crs_transformation.destEPSG}")

            self.__displaceCentroid(cluster_centroid_ft, crs_transformation)

        self.writeLayers()

        self.reloadLayerFromDiskToAvoidMemoryFlag()

    def clearLayers(self) -> typing.NoReturn:
        """ Clear all the layers of project instance that have been generated by this class
        """
        Utils.removeLayerIfExists(Utils.LayersType.BUFFERSANON)
        Utils.removeLayerIfExists(Utils.LayersType.LINKS)
        Utils.removeLayerIfExists(Utils.LayersType.DISPLACED)
        Utils.removeLayerIfExists(Utils.LayersType.DISPLACEDANON)

        Utils.removeLayerIfExists(Utils.LayersType.CENTROIDS_BUFFERS)
        # actually generated elsewher, but depends on this computation

        self.__generatedLayers.clear()

    def writeLayers(self) -> typing.NoReturn:
        """ Write all the layers handle by this class to files
        """
        Utils.writeLayerIfExists(Utils.LayersType.BUFFERSANON)
        # Utils.writeLayerIfExists(Utils.LayersType.LINKS)
        # Utils.writeLayerIfExists(Utils.LayersType.DISPLACED)
        Utils.writeLayerIfExists(Utils.LayersType.DISPLACEDANON)

        Logger.logInfo("[CentroidsDisplacer] Layers written to disk")

    def reloadLayerFromDiskToAvoidMemoryFlag(self) -> typing.NoReturn:
        """ Write all the layers handle by this class to files
        """
        Utils.reloadLayerFromDiskToAvoidMemoryFlag(Utils.LayersType.BUFFERSANON)
        # Utils.reloadLayerFromDiskToAvoidMemoryFlag(Utils.LayersType.LINKS)
        # Utils.reloadLayerFromDiskToAvoidMemoryFlag(Utils.LayersType.DISPLACED)
        Utils.reloadLayerFromDiskToAvoidMemoryFlag(Utils.LayersType.DISPLACEDANON)

## #############################################################
# Accessors
## #############################################################

    def setReferenceLayer(self, referenceLayerFile: str) -> typing.NoReturn:
        """ Update reference layer
            Change of reference imply a clearing
        """
        self.clearLayers()
        self.referenceLayer.load(referenceLayerFile)

    def setCentroidsLayer(self, centroidsLayer: QgsVectorLayer) -> typing.NoReturn:
        """ Update centroids layer.
            Change of reference imply a clearing.
        """
        self.clearLayers()
        self.centroidLayer = centroidsLayer

####################################################################
# DisplaceCentroids
####################################################################

    def __displaceCentroid(self, cluster_centroid_ft: QgsFeature, crs_transformation: Transforms) -> typing.NoReturn:
        """ Displace a centroid identify by a qgsfeature object
        """
        # copy geometry of centroid
        cluster_centroid_ft_geom_merc = QgsGeometry(cluster_centroid_ft.geometry())
        # transform copy of the centroid into Web Mercator
        cluster_centroid_ft_geom_merc.transform(crs_transformation.tr)
        # cluster_centroid_ft_geom_merc

        # cluster centroid coordinates in Web Mercator
        x = cluster_centroid_ft_geom_merc.asPoint().x()
        y = cluster_centroid_ft_geom_merc.asPoint().y()

        # get subnational ID for the cluster
        subnational_ids = self.referenceLayer.ref_fts_index.intersects(cluster_centroid_ft.geometry().boundingBox())
        intersecting_fts = []
        for s in subnational_ids:
            ft = self.referenceLayer.layer.getFeature(s)
            if ft.geometry().intersects(cluster_centroid_ft.geometry()):
                intersecting_fts.append(ft)
        if len(intersecting_fts) == 0:
            ref_id_before = 'None'
        elif len(intersecting_fts) == 1:
            ref_ft_before = intersecting_fts[0]
            ref_id_before = Utils.getval(ref_ft_before, self.ref_id_field)
        else:
            ref_id_before = 'Many'

        # retrieve correct max_displace_distance
        max_displace_distance = self.maxDistances[cluster_centroid_ft[0]]

        # iterate
        con = True
        iterations = 0
        while con:
            # call displacement function
            new_x, new_y, distance, angle_degree = self.__displacepoint(x, y, max_displace_distance)

            # create geometry of a displaced centroid in Web Mercator
            displaced_point_mercator = QgsPointXY(new_x, new_y)

            # copy geometry of a displaced centroid
            displaced_geom_wgs = QgsGeometry.fromPointXY(displaced_point_mercator)

            # transform copy of geometry of a displaced centroid into WGS84
            displaced_geom_wgs.transform(crs_transformation.tr_back)
            # displaced_point_wgs

            # get subnational ID for the cluster
            subnational_ids_after = self.referenceLayer.ref_fts_index.intersects(displaced_geom_wgs.boundingBox())
            intersecting_fts_after = []
            for s in subnational_ids_after:
                ft = self.referenceLayer.layer.getFeature(s)
                if ft.geometry().intersects(displaced_geom_wgs):
                    intersecting_fts_after.append(ft)
            if len(intersecting_fts_after) == 0:
                ref_id_after = 'None'
            elif len(intersecting_fts_after) == 1:
                ref_ft_after = intersecting_fts_after[0]
                ref_id_after = Utils.getval(ref_ft_after, self.ref_id_field)
            else:
                ref_id_after = 'Many'

            if ref_id_after == ref_id_before:
                con = False
            iterations += 1
            if iterations > CentroidsDisplacer.MAX_ITERATIONS:
                con = False

        self.__updateOutputsMemoryLayer(
            cluster_centroid_ft,
            displaced_geom_wgs,
            distance,
            angle_degree,
            ref_id_before,
            max_displace_distance,
            ref_id_after,
            iterations,
            crs_transformation)

####################################################################
# DisplacePoint
####################################################################
        
    def __displacepoint(self, x: float, y: float, max_distance: float = 5000) -> typing.Tuple[float, float, float, int]:
        """ Compute a point displacement
        """
        # calculates new point up to a given distance away from original point.All values should be provided in meters

        # Generate a random angle between 0 and 360
        angle_degree_internal = random.randint(0, 360)
        # Convert the random angle from degrees to radians
        angle_radian = angle_degree_internal * (math.pi / 180)

        # Generate a random distance by multiplying the max distance by a random number between 0 and 1
        distance_internal = random.random() * max_distance

        # Generate the offset by applying trig formulas (law of cosines) using the distance as the hypotenuse solving for
        # the other sides
        x_offset = math.sin(angle_radian) * distance_internal
        y_offset = math.cos(angle_radian) * distance_internal

        # Add the offset to the original coordinate (in meters)
        new_x_internal = x + x_offset
        new_y_internal = y + y_offset

        return new_x_internal, new_y_internal, distance_internal, angle_degree_internal

####################################################################
# Layers
####################################################################

    def __createOutputsMemoryLayer(self) -> typing.NoReturn:
        """ generate output memory layer
        """
        # create layer for anonymised buffers
        self.__generatedLayers[Utils.LayersType.BUFFERSANON] = Utils.createLayer('Polygon?crs='+CRS.WGS84, Utils.LayersType.BUFFERSANON, [
            QgsField("cluster", QVariant.Int),
            QgsField("type", QVariant.String),
            QgsField("buf_dist", QVariant.Int)
        ])

        # create layer for displacement links
        self.__generatedLayers[Utils.LayersType.LINKS] = Utils.createLayer('LineString?crs='+CRS.WGS84, Utils.LayersType.LINKS, [
            QgsField("cluster", QVariant.Int),
            QgsField("type", QVariant.String),
            QgsField("count", QVariant.Int),
            QgsField("lon_orig", QVariant.Double, "double", 15, 6),
            QgsField("lat_orig", QVariant.Double, "double", 15, 6),
            QgsField("lon_disp", QVariant.Double, "double", 15, 6),
            QgsField("lat_disp", QVariant.Double, "double", 15, 6),
            QgsField("disp_dist", QVariant.Double, "double", 15, 2),
            QgsField("disp_angle", QVariant.Int),
            QgsField("ref_cl_src", QVariant.String),
            QgsField("ref_orig", QVariant.String),
            QgsField("ref_disp", QVariant.String),
            QgsField("iter", QVariant.Int)
        ])

        # create layer for displaced centroids
        self.__generatedLayers[Utils.LayersType.DISPLACED] = Utils.createLayer('Point?crs='+CRS.WGS84, Utils.LayersType.DISPLACED, [
            QgsField("cluster", QVariant.Int),
            QgsField("type", QVariant.String),
            QgsField("count", QVariant.Int),
            QgsField("lon_orig", QVariant.Double, "double", 15, 6),
            QgsField("lat_orig", QVariant.Double, "double", 15, 6),
            QgsField("lon_disp", QVariant.Double, "double", 15, 6),
            QgsField("lat_disp", QVariant.Double, "double", 15, 6),
            QgsField("disp_dist", QVariant.Double, "double", 15, 2),
            QgsField("disp_angle", QVariant.Int),
            QgsField("tr_epsg", QVariant.String),
            QgsField("ref_cl_src", QVariant.String),
            QgsField("ref_orig", QVariant.String),
            QgsField("ref_disp", QVariant.String),
            QgsField("iter", QVariant.Int),
            QgsField("Remarks", QVariant.String)
        ])

        # create layer for anonymised displaced centroids
        self.__generatedLayers[Utils.LayersType.DISPLACEDANON] = Utils.createLayer('Point?crs='+CRS.WGS84, Utils.LayersType.DISPLACEDANON, [
            QgsField("HH1", QVariant.Int),
            QgsField("HH6", QVariant.String),
            QgsField("Longitude", QVariant.Double, "double", 15, 6),
            QgsField("Latitude", QVariant.Double, "double", 15, 6),  
            QgsField("MICSGEO", QVariant.String)
        ])

        # add layers to project following correct z order
        QgsProject.instance().addMapLayer(self.__generatedLayers[Utils.LayersType.BUFFERSANON])
        QgsProject.instance().addMapLayer(self.__generatedLayers[Utils.LayersType.LINKS])
        Utils.putLayerOnTopIfExists(Utils.LayersType.CENTROIDS)  # fix z order
        QgsProject.instance().addMapLayer(self.__generatedLayers[Utils.LayersType.DISPLACED])
        QgsProject.instance().addMapLayer(self.__generatedLayers[Utils.LayersType.DISPLACEDANON])

    def __updateOutputsMemoryLayer(self,
                                   cluster_centroid_ft: QgsFeature,
                                   displaced_point_wgs: QgsGeometry,
                                   distance: float,
                                   angle_degree: float,
                                   ref_id_before: str,
                                   max_displace_distance: float,
                                   ref_id_after: str,
                                   iterations,
                                   crs_transformation: Transforms) -> typing.NoReturn:
        """ updates all the outputs layer
        """

        # add displaced centroid
        feat_disp_centroid = QgsFeature()
        feat_disp_centroid.setGeometry(displaced_point_wgs)

        remark = Errors.ErrorDisplayString[Errors.ErrorCode.SUCCESS]
        if not cluster_centroid_ft['cluster']:
            remark = Errors.ErrorDisplayString[Errors.ErrorCode.ERROR_DISPLACER_NUMBER_MISSING]
        if not cluster_centroid_ft['type']:
            remark = Errors.ErrorDisplayString[Errors.ErrorCode.ERROR_DISPLACER_AREA_MISSING]
        if not cluster_centroid_ft['admin']:
            remark = Errors.ErrorDisplayString[Errors.ErrorCode.ERROR_DISPLACER_ADMIN_MISSING]
        if ref_id_before == "None" or ref_id_after == "None":
            remark = Errors.ErrorDisplayString[Errors.ErrorCode.ERROR_DISPLACER_CLUSTER_OUTSIDE_BOUNDARY]
        if cluster_centroid_ft['admin'] != ref_id_before or ref_id_before != ref_id_after:
            remark = Errors.ErrorDisplayString[Errors.ErrorCode.ERROR_DISPLACER_CLUSTER_DISPLACED_OUTSIDE_GEODOMAIN]

        #
        feat_disp_centroid.setAttributes([
            cluster_centroid_ft['cluster'],
            cluster_centroid_ft['type'],
            cluster_centroid_ft['count'],
            cluster_centroid_ft.geometry().asPoint().x(),
            cluster_centroid_ft.geometry().asPoint().y(),
            displaced_point_wgs.asPoint().x(),
            displaced_point_wgs.asPoint().y(),
            distance,
            angle_degree,
            crs_transformation.destEPSG,
            cluster_centroid_ft['admin'],
            ref_id_before,
            ref_id_after,
            iterations,
            remark
        ])
        self.__generatedLayers[Utils.LayersType.DISPLACED].dataProvider().addFeatures([feat_disp_centroid])

        # add anonymised displaced centroid
        feat_anonym_disp_centroid = QgsFeature()
        feat_anonym_disp_centroid.setGeometry(displaced_point_wgs)
        feat_anonym_disp_centroid.setAttributes([
            cluster_centroid_ft['cluster'],
            cluster_centroid_ft['type'],
            displaced_point_wgs.asPoint().x(),
            displaced_point_wgs.asPoint().y(),
            cluster_centroid_ft['admin']
        ])
        self.__generatedLayers[Utils.LayersType.DISPLACEDANON].dataProvider().addFeatures([feat_anonym_disp_centroid])

        # add displacement links
        centroid_disp_links_ft = QgsFeature()
        centroid_disp_links_ft.setGeometry(QgsGeometry.fromPolylineXY([cluster_centroid_ft.geometry().asPoint(), feat_disp_centroid.geometry().asPoint()]))
        centroid_disp_links_ft.setAttributes([
            cluster_centroid_ft['cluster'],
            cluster_centroid_ft['type'],
            cluster_centroid_ft['count'],
            cluster_centroid_ft.geometry().asPoint().x(),
            cluster_centroid_ft.geometry().asPoint().y(),
            displaced_point_wgs.asPoint().x(),
            displaced_point_wgs.asPoint().y(),
            distance,
            angle_degree,
            cluster_centroid_ft['admin'],
            ref_id_before,
            ref_id_after,
            iterations
        ])
        self.__generatedLayers[Utils.LayersType.LINKS].dataProvider().addFeatures([centroid_disp_links_ft])

        # copy geometry of displaced centroid
        displaced_feat_centroid_mercator = QgsGeometry(feat_disp_centroid.geometry())

        # transform copy of the centroid into Web Mercator
        displaced_feat_centroid_mercator.transform(crs_transformation.tr)

        # get the area type
        area_type = cluster_centroid_ft['type']

        # set the buffer radius based on the area type
        if area_type == Utils.FieldAreaType.URBAN:
            buffer_radius = 2000
        elif area_type == Utils.FieldAreaType.RURAL:
            buffer_radius = 5000
        else:
            buffer_radius = 5000

        # create buffers around displaced centroids
        disp_centroid_buff_geom = displaced_feat_centroid_mercator.buffer(buffer_radius, 20)

        disp_centroid_buff_geom.transform(crs_transformation.tr_back)

        # create buffers around displaced centroids
        disp_anonym_centroid_buff_ft = QgsFeature()
        disp_anonym_centroid_buff_ft.setGeometry(disp_centroid_buff_geom)
        disp_anonym_centroid_buff_ft.setAttributes([
            cluster_centroid_ft['cluster'],
            cluster_centroid_ft['type'],
            buffer_radius
        ])
        self.__generatedLayers[Utils.LayersType.BUFFERSANON].dataProvider().addFeatures([disp_anonym_centroid_buff_ft])
